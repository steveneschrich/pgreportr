% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/is.R
\name{dispatch_on_field}
\alias{dispatch_on_field}
\title{Operator overloading function}
\usage{
dispatch_on_field(tb, name)
}
\arguments{
\item{tb}{A data.frame or tibble to extract a value from. May be NULL to retrieve the name itself.}

\item{name}{The name of the variable to extract}
}
\value{
Either a name (as a symbol, if the table value is NULL) or a list of values from the field.
}
\description{
For many cases, we would like to not expose the specifics of the indicator variables in the
dataset explicitly, since function calls are the things that are well documented in the library.
}
\details{
Therefore, we essentially have getters for a variety of variables but with a small twist. The
simplest form of usage is to say grants \%>\% is_phsu_cancer_related() or more simply,
is_phsu_cancer_related(grants). This would return the underlying variable
(is_phsu_cancer_related) which is already a logical. However, it would be
clearly documented as a function call (rather than having to know the specific field).

The second, less clear usage of the function is when trying to use it in a dplyr statement. For instance,
in filter: grants \%>\% filter(!!is_phsu_cancer_related()) allows us to filter on a field that I might
not know the name of but is clearly documented within the function.

This function is the general-purpose operator overload dispatcher that figures out, based on whether
or not an argument is provided, whether to return the variable name (for !!) or to return a list of
values (if I provided a table).

In practical terms (within the library), you can then define a new function is_phsu_related() that
just calls this dispatcher with the appropriate variable name. Essentially a java-like getter.
}
